# -*- coding: utf-8 -*-
"""Recommendation System - Indonesia Tourism.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/115XoaTAUuR8MCbv4HJvcKAZRioR8HpVv

# Introduction

## Recommendation System - Indonesia Tourism

by: Sri Agung Tirtayasa

dataset: https://www.kaggle.com/datasets/aprabowo/indonesia-tourism-destination

# Preparation
"""

# Install kaggle library

!pip install kaggle -q

# Import all required library

from google.colab import files
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel, cosine_similarity

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import Embedding
from tensorflow.keras.losses import BinaryCrossentropy
from tensorflow.keras.metrics import RootMeanSquaredError
from tensorflow.keras.optimizers import Adam

# Upload kaggle credentials

files.upload()

# Make directory for credentials and dataset

!mkdir -p ~/.kaggle
!mv kaggle.json ~/.kaggle
!chmod 600 ~/.kaggle/kaggle.json
!mkdir datasets

# Download dataset link: https://www.kaggle.com/datasets/aprabowo/indonesia-tourism-destination

!kaggle datasets download -d aprabowo/indonesia-tourism-destination

!unzip indonesia-tourism-destination.zip -d datasets

# Load all dataset

df_package = pd.read_csv('datasets/package_tourism.csv')
df_tourism = pd.read_csv('datasets/tourism_with_id.csv')
df_user = pd.read_csv('datasets/user.csv')
df_transaction = pd.read_csv('datasets/tourism_rating.csv')

"""# Data Understanding

Dataset ini terdiri dari 4 file csv

package_tourism.csv = dataset daftar paket wisata

Features:
- Package: ID dari paket
- City: Kota paket wisata
- PlaceTourism1: Tempat paket wisata 1
- PlaceTourism2: Tempat paket wisata 2
- PlaceTourism3: Tempat paket wisata 3
- PlaceTourism4: Tempat paket wisata 4
- PlaceTourism5: Tempat paket wisata 5


tourism_with_id.csv = dataset daftar tempat wisata

Features:
- Place_Id: ID dari tempat wisata
- Place_Name: Nama dari tempat wisata
- Description: Deskripsi tempat wisata
- Category: Kategori tempat wisata
- City: Kota tempat wisata
- Price: Harga tempat wisata
- Rating: Rating tempat wisata
- Time_Minute: -
- Coordinate: Titik koordinat dalam bentuk json 'lat' dan 'lng'
- Lat: Latitude
- Long: Longitude


user.csv = daftar user

Features
- User_Id: ID dari user
- Location: Kota dan provinsi tempat tinggal user
- Age: Umur user

tourism_rating.csv = daftar rating tempat

Features:
- Place_Id: ID dari tempat wisata
- User_Id: ID dari user
- Place_Ratings: Rating dari user ke tempat wisata


"""

df_package.info()

df_package.head()

df_package.reset_index()
df_package.set_index('Package')
df_package.fillna('')

df_tourism.info()

df_tourism.head()

df_tourism.drop(['Unnamed: 11', 'Unnamed: 12', 'Time_Minutes'], axis=1, inplace=True)
df_tourism.reset_index()
df_tourism.set_index('Place_Id')

df_user.info()

df_user.head()

df_user.reset_index()
df_user.set_index('User_Id')

df_transaction.info()

df_transaction.head()

"""# EDA"""

df_tourism['Category'].unique()

df_tourism['City'].unique()

tourism_category_price = df_tourism.groupby('Category')['Price']
tourism_category_price.mean().sort_values().plot(kind='bar'), tourism_category_price.describe()

df_transaction = pd.merge(df_transaction, df_tourism[['Place_Id', 'Category', 'City']], on='Place_Id', how='left')

pd.DataFrame(index=df_tourism['Category'].unique(), data={
    'Rating': df_tourism.groupby('Category')['Rating'].mean().sort_values(),
    'User Rating': df_transaction.groupby('Category')['Place_Ratings'].mean().sort_values(),
  }).plot(kind='bar')

df_transaction.groupby('Category')['Place_Ratings'].value_counts().sort_index().plot(kind='bar')

df_transaction.groupby('Category')['Place_Ratings'].count().sort_values().plot(kind='bar')

tourism_city_price = df_tourism.groupby('City')['Price']
tourism_city_price.mean().sort_values().plot(kind='bar'), tourism_city_price.describe()

pd.DataFrame(index=df_tourism['City'].unique(), data={
    'Rating': df_tourism.groupby('City')['Rating'].mean().sort_values(),
    'User Rating': df_transaction.groupby('City')['Place_Ratings'].mean().sort_values(),
  }).plot(kind='bar')

df_transaction.groupby('City')['Place_Ratings'].value_counts().sort_index().plot(kind='bar')

df_transaction.groupby('City')['Place_Ratings'].count().sort_values().plot(kind='bar')

df_transaction.groupby('Category')['User_Id'].count().sort_values().plot(kind='bar')

df_transaction.groupby('City')['User_Id'].count().sort_values().plot(kind='bar')

pd.Series(df_tourism['Price'].unique()).sort_values().plot(kind='bar')

print('Jumlah Tempat Wisata: ', len(df_tourism['Place_Id'].unique()))
print('Jumlah User: ', len(df_user['User_Id'].unique()))
print('Jumlah Rating User: ', len(df_transaction['User_Id'].unique()))
print('Jumlah Rating Tempat Wisata: ', len(df_transaction['Place_Id'].unique()))
print('Jumlah Rating: ', len(df_transaction))
print('Jumlah Paket: ', len(df_package))

pd.DataFrame(data={'Jumlah': [
  len(df_tourism[df_tourism['Price'] == 0]),
  len(df_tourism[(df_tourism['Price'] <= 100000) & (df_tourism['Price'] > 0)]),
  len(df_tourism[(df_tourism['Price'] <= 200000) & (df_tourism['Price'] > 100000)]),
  len(df_tourism[df_tourism['Price'] > 200000])
]}, index=('Gratis', 'Murah', 'Lumayan', 'Mahal'))

"""Fitur Price dapat diesktrak menjadi fitur baru yaitu Budget sebagai indikasi pengaluaran uang dalam bentuk teks

```
Price == 0 (Gratis)
Price > 0 & Price <= 100000 (Murah)
Price > 100000 & Price <= 200000 (Lumayan)
Price > 200000 (Mahal)
```
"""

def set_budget(price):
  if price == 0:
    return 'Gratis'
  elif price <= 100000:
    return 'Murah'
  elif price <= 20000:
    return 'Lumayan'
  else:
    return 'Mahal'

df_tourism['Budget'] = df_tourism['Price'].apply(set_budget)
df_tourism.head()

df_tourism.isna().sum()

"""Hanya fitur Time_Minute yang terdapat null, tetapi fitur itu tidak akan dipakai jadi bisa dibiarkan saja

# Model & Evaluation

Untuk Content Based Filtering teknik yang digunakan yaitu cosine similiarity dan metrik yang digunakan yaitu precission terhadap rekomendasi yang diberikan.

Formula precission:
\begin{array}{rcl}
precission & = & \dfrac{\text{# Relevant recommendations}}{\text{# Top items recommended}}
\end{array}

Untuk Collaborative Filtering teknik yang akan digunakan yaitu embedding dan metrik yang digunakan yaitu RMSE (_Root Mean Squared Error_)

Formula RMSE:

\begin{array}{rcl}
\text{RMSE}(y, \hat{y}) = \sqrt{\frac{\sum_{i=0}^{N - 1} (y_i - \hat{y}_i)^2}{N}}
\end{array}

## Content Based Filtering

Content yang akan digunakan sebagai filtering akan menggunakan beberapa fitur yang akan digabung menjadi sebuah "_Metadata_". Fitur yang akan digunakan yaitu Category, City, Budget dan Description.
"""

features = ['Category', 'City', 'Budget', 'Description']

df_tourism['Metadata'] = ''

for feature in features:
  df_tourism['Metadata'] += (df_tourism[feature].str.lower() + ' ')

df_tourism['Metadata']

tfidf = TfidfVectorizer()

tfidf_matrix = tfidf.fit_transform(df_tourism['Metadata'].fillna(''))

tfidf_matrix.shape

"""Formula cosine similarity:

$Cosine(x,y) = \frac{x \cdot y}{|x||y|}$
"""

cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
cosine_sim.shape

tourism = pd.Series(df_tourism.index, index=df_tourism['Place_Name']).drop_duplicates()
tourism

def get_recommendations_by_place(place, k = 5):
  index = tourism[place]
  category = df_tourism[df_tourism['Place_Id'] == index]['Category'].values[0]
  print("Jika Anda suka tempat wisata {} dengan tema {}, mungkin beberapa tempat ini cocok untuk Anda\n\n".format(place, category))
  similarities = cosine_sim[index]
  similarity_scores = list(enumerate(similarities))
  similarity_scores = sorted(similarity_scores , key=lambda x: x[1], reverse = True)
  similarity_scores = similarity_scores[1:k + 1]
  similar_indexes = [x[0] for x in similarity_scores]

  recommend_places = df_tourism.iloc[similar_indexes]

  return recommend_places[['Place_Name', 'Category']]

get_recommendations_by_place('Kota Tua', 10)

"""Hasil rekomendasi menunjukan hasil yang cukup baik dalam content based filtering.

Hasil diatas menunjukan tingkat presisi yang tinggi untuk kategori tempat wisata.

$p = \frac{7}{10} = 70 \text{%}$

## Collaborative Filtering
"""

df_transaction.head()

df_transaction['Place_Ratings'].describe()

df_transaction = df_transaction.sample(frac=1, random_state=112)
df_transaction

min_rating = min(df_transaction['Place_Ratings'])
max_rating = max(df_transaction['Place_Ratings'])

X = df_transaction[['User_Id', 'Place_Id']].values
y = df_transaction['Place_Ratings'].apply(lambda x: (x - min_rating) / (max_rating - min_rating)).values

# Split data 8:2 train:val
train_indices = int(.8 * df_transaction.shape[0])
X_train, X_val, y_train, y_val = [
    X[:train_indices],
    X[train_indices:],
    y[:train_indices],
    y[train_indices:],
]

print(X, y)

class RecommenderNet(tf.keras.Model):

  def __init__(self, num_users, num_place, embedding_size, **kwargs):
    super(RecommenderNet, self).__init__(**kwargs)
    self.num_users = num_users
    self.num_place = num_place
    self.embedding_size = embedding_size
    self.user_embedding = Embedding(
        num_users,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.user_bias = Embedding(num_users, 1)
    self.place_embedding = Embedding(
        num_place,
        embedding_size,
        embeddings_initializer = 'he_normal',
        embeddings_regularizer = keras.regularizers.l2(1e-6)
    )
    self.place_bias = Embedding(num_place, 1)

  def call(self, inputs):
    user_vector = self.user_embedding(inputs[:, 0])
    user_bias = self.user_bias(inputs[:, 0])
    place_vector = self.place_embedding(inputs[:, 1])
    place_bias = self.place_bias(inputs[:, 1])

    dot_user_resto = tf.tensordot(user_vector, place_vector, 2)

    x = dot_user_resto + user_bias + place_bias

    return tf.nn.sigmoid(x)

num_users = len(df_transaction['User_Id'])
num_place = len(df_transaction['Place_Id'])

model = RecommenderNet(num_users, num_place, 32)

model.compile(
    loss = BinaryCrossentropy(),
    optimizer = Adam(learning_rate = 0.001),
    metrics = [RootMeanSquaredError()]
)

history = model.fit(
    x = X_train,
    y = y_train,
    batch_size = 8,
    epochs = 72,
    validation_data = (X_val, y_val)
)

plt.plot(history.history['root_mean_squared_error'])
plt.plot(history.history['val_root_mean_squared_error'])
plt.title('model_metrics')
plt.ylabel('root_mean_squared_error')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

def get_recommendation_by_user(user_id, k = 5):
  visited = df_transaction[df_transaction['User_Id'] == user_id]
  not_visited = df_tourism[~df_tourism['Place_Id'].isin(visited['Place_Id'].values)]['Place_Id']

  # most_visited = df_transaction[(df_transaction['Place_Id'].isin(visited['Place_Id'].values)) & (df_transaction['User_Id'] == user_id)]['Category'].value_counts()

  user_with_not_visited = np.array([[user_id, x] for x in not_visited])

  ratings = model.predict(user_with_not_visited).flatten()

  top_ratings_indices = ratings.argsort()[-k:][::-1]
  recommended_place_ids = df_tourism[df_tourism['Place_Id'].isin(top_ratings_indices)]

  print('Tempat dengan rating tertinggi dari user ', user_id, '\n\n')
  top_user_places = visited.sort_values(by='Place_Ratings', ascending=False).head(5)['Place_Id']
  for top_place in df_tourism[df_tourism['Place_Id'].isin(top_user_places)].itertuples():
    print(top_place.Place_Name, ':', top_place.Category)

  print(f'\n\nTop {k} Rekomendasi tempat wisata')
  for top_recommend in recommended_place_ids.itertuples():
    print(top_recommend.Place_Name, ':', top_recommend.Category)

  return recommended_place_ids[['Place_Name', 'Category']]

get_recommendation_by_user(14, 10)